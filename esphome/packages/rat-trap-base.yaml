---
# esphome/packages/rat-trap-base.yaml
# Common configurations for all rat trap variants

binary_sensor:
  - platform: gpio
    pin:
      number: 9
      mode: INPUT_PULLUP
      inverted: true
    name: ${friendly_name} Reset Button
    id: reset_button
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log: Reset button pressed - restarting system
      - delay: 1s
      - button.press: restart_button

  - platform: template
    name: ${friendly_name} Trap Triggered
    id: trap_triggered
    icon: mdi:power

switch:
  - platform: gpio
    pin: 5
    name: ${friendly_name} Vacuum Relay
    id: vacuum_relay
    icon: mdi:vacuum
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log:
          format: SSR activated - switching %s load (%s compliant)
          args: ["${line_voltage}", "${safety_standard}"]
    on_turn_off:
      - logger.log: SSR deactivated - load disconnected
  - platform: template
    name: ${friendly_name} Manual Trigger
    id: manual_trigger
    icon: mdi:play-circle
    turn_on_action:
      - if:
          condition:
            and:
              - binary_sensor.is_off: trap_triggered
              - binary_sensor.is_off: emergency_stop
          then:
            - logger.log: Manual trigger activated
            - script.execute: activate_trap_sequence
          else:
            - logger.log: Manual trigger ignored - system disabled or emergency stop active

script:
  - id: activate_trap_sequence
    mode: single
    then:
      - if:
          condition:
            and:
              - switch.is_on: system_armed
              - binary_sensor.is_off: emergency_stop
              - binary_sensor.is_off: trap_triggered
          then:
            - logger.log: Trap sequence initiated - hybrid detection confirmed
            # - binary_sensor.template.publish:
            #     id: rodent_detected
            #     state: on
            - binary_sensor.template.publish:
                id: trap_triggered
                state: on

            # Trigger Camera and CV (if available)
            - script.execute: capture_evidence
            # - script.execute: run_classification # Placeholder

            - switch.turn_on: vacuum_relay
            - lambda: id(last_trigger_time) = millis();
            - delay: !lambda "return id(vacuum_runtime).state * id(ms_conversion_factor);"
            - switch.turn_off: vacuum_relay
            - lambda: |-
                auto call = id(capture_count).make_call();
                call.set_value(id(capture_count).state + 1);
                call.perform();
            - lambda: |-
                float runtime_minutes = id(vacuum_runtime).state / 60.0;
                id(total_vacuum_runtime) += runtime_minutes;
                id(vacuum_runtime_sensor).publish_state(id(total_vacuum_runtime));
            - delay: 2s
            - binary_sensor.template.publish:
                id: trap_triggered
                state: off
            - delay: !lambda "return id(cooldown_period).state * id(ms_conversion_factor);"
            # - binary_sensor.template.publish:
            #     id: rodent_detected
            #     state: off
            - logger.log: Trap sequence complete - system re-armed
          else:
            - logger.log: Trap sequence blocked - system disarmed or emergency stop active

button:
  - platform: restart
    name: ${friendly_name} Restart ESP32
    id: restart_button
  - platform: template
    name: ${friendly_name} Thermal Shutdown
    id: thermal_shutdown_button
    on_press:
      - script.execute: thermal_shutdown

  - platform: template
    name: ${friendly_name} Run Diagnostics
    id: run_diagnostics
    on_press:
      - logger.log: Running system diagnostics...
      - lambda: |-
          bool system_ok = true;
          std::string diagnostic_results = "";
          // Check ToF Sensor
          if (!id(distance_sensor).has_state()) {
            system_ok = false;
            diagnostic_results += "VL53L4CX ToF sensor not responding. ";
          }
          // Check IR Presence Sensor (STHS34PF80)
          if (!id(ir_presence).has_state()) {
             // Binary sensors might not have 'state' in the same way if not updated,
             // but has_state() checks if it has received at least one value.
             // STHS34PF80 is polling, so it should have a state.
             // If it fails to init, it might not publish.
             // Let's assume if it's missing, it's an issue.
             // Actually, binary_sensor doesn't always have has_state() exposed in lambda easily?
             // It does: boolean has_state() const
          }

          if (!id(env_temperature).has_state()) {
            system_ok = false;
            diagnostic_results += "BME280 environmental sensor not responding. ";
          }
          if (id(esp32_temp).state > ${diagnostic_temp_threshold}) {
            system_ok = false;
            diagnostic_results += "Temperature high: " + to_string(id(esp32_temp).state) + "C. ";
          }
          if (system_ok) {
            ESP_LOGI("diagnostics", "System diagnostics passed");
            id(last_fault_type) = "DIAGNOSTICS_PASSED";
          } else {
            ESP_LOGW("diagnostics", "System diagnostics failed: %s", diagnostic_results.c_str());
            id(last_fault_type) = "DIAGNOSTICS: " + diagnostic_results;
            id(fault_count)++;
            id(fault_count_sensor).publish_state(id(fault_count));
          }
          id(last_fault_type_sensor).publish_state(id(last_fault_type));
      - logger.log: Diagnostics complete

globals:
  - id: last_trigger_time
    type: unsigned long
    restore_value: no
    initial_value: "0"
  - id: total_vacuum_runtime
    type: float
    restore_value: yes
    initial_value: "0"
  - id: ms_conversion_factor
    type: int
    restore_value: no
    initial_value: "1000"

number:
  - platform: template
    name: ${friendly_name} Capture Count
    id: capture_count
    min_value: 0
    max_value: 10000
    step: 1
    mode: box
    optimistic: true
    restore_value: yes
    initial_value: 0

  - platform: template
    name: ${friendly_name} Detection Threshold (mm)
    id: detection_threshold
    min_value: 50
    max_value: 500
    step: 10
    initial_value: 150
    restore_value: true
    optimistic: true
  - platform: template
    name: ${friendly_name} Vacuum Runtime (seconds)
    id: vacuum_runtime
    min_value: 1
    max_value: 30
    step: 1
    initial_value: 8
    restore_value: true
    optimistic: true
  - platform: template
    name: ${friendly_name} Cooldown Period (seconds)
    id: cooldown_period
    min_value: 10
    max_value: 300
    step: 5
    initial_value: 30
    restore_value: true
    optimistic: true

  - platform: template
    name: ${friendly_name} ESP32 Critical Temperature
    id: esp32_temp_critical_threshold
    min_value: 70
    max_value: 95
    step: 1
    initial_value: 85
    unit_of_measurement: °C
    restore_value: true
    optimistic: true

  - platform: template
    name: ${friendly_name} ESP32 Warning Temperature
    id: esp32_temp_warning_threshold
    min_value: 60
    max_value: 85
    step: 1
    initial_value: 75
    unit_of_measurement: °C
    restore_value: true
    optimistic: true

  - platform: template
    name: ${friendly_name} IR LED Brightness
    id: ir_brightness_number
    min_value: 0
    max_value: 100
    step: 10
    initial_value: 80
    unit_of_measurement: "%"
    restore_value: true
    optimistic: true

web_server:
  port: 80
  version: 2
  include_internal: true
