esphome:
  name: rat-trap-2025
  friendly_name: "ShopVac Rat Trap 2025"
  platform: ESP32
  board: adafruit_feather_esp32s3
  comment: "NEC/IEC compliant ESP32-S3 based rat trap with STEMMA QT sensors"

# Hardware variant selection - Choose your configuration
# STANDARD: ESP32-S3 Feather with basic sensors
# ENHANCED VERSION: ESP32-S3 with VL53L0X ToF sensor, OLED display, BME280 environmental monitoring
substitutions:
  hardware_variant: "STANDARD"  # Options: STANDARD, CAMERA

# Enhanced ESP32-S3 configuration (Standard variant)
esp32:
  variant: esp32s3
  board: adafruit_feather_esp32s3
  framework:
    type: arduino

# Note: For CAMERA variant, use rat-trap-camera-enhanced.yaml instead

# Voltage-specific configuration (uncomment appropriate section)
substitutions:
  # ðŸ‡ºðŸ‡¸ North America (120V AC, 60Hz, NEC compliant)
  line_volta      // System monitoring
      if (id(wifi_signal).has_state()) {
        it.printf(0, 56, id(font_small), "WiFi: %.0fdBm  CPU: %.1fÂ°C",
                  id(wifi_signal).state, id(esp32_temp).state);
      } else {
        it.printf(0, 56, id(font_small), "ESP32 Temp: %.1fÂ°C", id(esp32_temp).state);
      }

      // Thermal warning indicator
      if (id(esp32_temp).has_state() && id(esp32_temp).state > 75.0) {
        it.print(120, 56, id(font_small), "!");  # Temperature warning
      }

# Voltage-specific configuration (uncomment appropriate section)
substitutions:
  # ðŸ‡ºðŸ‡¸ North America (120V AC, 60Hz, NEC compliant)
  line_voltage: "120V AC"
  line_frequency: "60Hz"
  max_current: "15A"
  safety_standard: "NEC/UL"

  # ðŸ‡ªðŸ‡º Europe (230V AC, 50Hz, IEC/CE compliant)
  # line_voltage: "230V AC"
  # line_frequency: "50Hz"
  # max_current: "10A"
  # safety_standard: "IEC/CE"

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "RatTrap2025 Fallback"
    password: !secret ap_password

captive_portal:

# I2C bus configuration for VL53L0X, BME280 and OLED via STEMMA QT with enhanced EMI protection
# Uses STEMMA QT 5-Port Hub (Adafruit 5625) to minimize cable count
# Hub connects: ESP32 â† Hub â†’ ToF, BME280, OLED
# RECOMMENDED: Use Adafruit QWIIC/STEMMA QT 5-Port Hub (5625) for improved cable management
# Hub Configuration: ESP32 â†’ Hub â†’ Individual devices (star topology)
# Legacy Configuration: ESP32 â†’ VL53L0X â†’ BME280 â†’ OLED (daisy chain)
i2c:
  sda: 21
  scl: 22
  scan: true
  frequency: 100kHz  # Reduced from 400kHz for better EMI immunity in high-voltage environment

# Enhanced Time-of-Flight sensor (VL53L0X - cost optimized, 2m range sufficient)
sensor:
  - platform: vl53l0x
    name: "Trap Distance"
    id: trap_distance
    address: 0x29
    update_interval: 50ms

  # BME280 environmental sensor via STEMMA QT (I2C)
  - platform: bme280
    address: 0x77  # Adafruit STEMMA QT BME280 default address
    temperature:
      name: "Environmental Temperature"
      id: env_temperature
      accuracy_decimals: 1
      filters:
        - sliding_window_moving_average:
            window_size: 5
            send_every: 5
      unit_of_measurement: "Â°C"
      device_class: temperature
      state_class: measurement
    humidity:
      name: "Environmental Humidity"
      id: env_humidity
      accuracy_decimals: 0
      unit_of_measurement: "%"
      device_class: humidity
      state_class: measurement
    pressure:
      name: "Barometric Pressure"
      id: env_pressure
      accuracy_decimals: 1
      unit_of_measurement: "hPa"
      device_class: atmospheric_pressure
      state_class: measurement
    update_interval: 60s
  # Distance-based rodent detection logic
  - platform: template
    name: "Trap Distance"
    id: trap_distance_template
    lambda: |-
      return id(trap_distance).state;
    filters:
      - sliding_window_moving_average:
          window_size: 20
          send_every: 5
      - lambda: |-
          // Reject obviously bad readings
          if (x > 4000 || x < 10) return {};
          return x;
    on_value_range:
      - below: 150.0  # 15cm threshold for rodent detection
        then:
          - if:
              condition:
                and:
                  - binary_sensor.is_off: trap_triggered
                  - lambda: 'return (millis() - id(last_trigger_time) > (id(cooldown_period).state * 1000));' # Configurable cooldown
              then:
                - logger.log: "Rodent detected! Triggering vacuum sequence."
                - binary_sensor.template.publish:
                    id: rodent_detected
                    state: ON
                - binary_sensor.template.publish:
                    id: trap_triggered
                    state: ON
                - switch.turn_on: vacuum_relay
                - lambda: 'id(last_trigger_time) = millis();'
                - delay: !lambda 'return id(vacuum_runtime).state * 1000;'  # Configurable runtime
                - switch.turn_off: vacuum_relay
                - lambda: |-
                    // Update capture count
                    id(capture_count) += 1;
                    id(capture_count_sensor).publish_state(id(capture_count));

                    // Update vacuum runtime tracking
                    float runtime_minutes = id(vacuum_runtime).state / 60.0;
                    id(total_vacuum_runtime) += runtime_minutes;
                    id(vacuum_runtime_sensor).publish_state(id(total_vacuum_runtime));
                - delay: 2s
                - binary_sensor.template.publish:
                    id: trap_triggered
                    state: OFF
                - delay: !lambda 'return id(cooldown_period).state * 1000;'  # Configurable cooldown
                - binary_sensor.template.publish:
                    id: rodent_detected
                    state: OFF
      - above: 200.0  # Clear detection threshold
        then:
          - if:
              condition:
                and:
                  - binary_sensor.is_off: trap_triggered
              then:
                - binary_sensor.template.publish:
                    id: rodent_detected
                    state: OFF

  # Capture count tracker with persistence
  - platform: template
    name: "Capture Count"
    id: capture_count_sensor
    icon: "mdi:counter"
    accuracy_decimals: 0
    state_class: total_increasing

  # Vacuum runtime tracking for maintenance scheduling
  - platform: template
    name: "Total Vacuum Runtime"
    id: vacuum_runtime_sensor
    icon: "mdi:vacuum"
    unit_of_measurement: "minutes"
    accuracy_decimals: 1
    device_class: duration
    state_class: total_increasing
    lambda: |-
      return id(total_vacuum_runtime);

  # System fault monitoring
  - platform: template
    name: "Fault Count"
    id: fault_count_sensor
    icon: "mdi:alert"
    accuracy_decimals: 0
    state_class: total_increasing
    lambda: |-
      return id(fault_count);

  # System monitoring sensors
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal
    update_interval: 60s

  - platform: uptime
    name: "System Uptime"
    id: uptime_sensor

  # ESP32 internal temperature monitoring with enhanced thermal management
  - platform: template
    name: "ESP32 Temperature"
    id: esp32_temp
    icon: "mdi:thermometer"
    unit_of_measurement: "Â°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
      return temperatureRead();
    update_interval: 15s  # More frequent monitoring for better thermal tracking
    filters:
      - sliding_window_moving_average:  # Smooth out temperature readings
          window_size: 4
          send_every: 2
      - lambda: |-
          // Enhanced thermal protection with tiered warnings
          static int high_temp_count = 0;
          static unsigned long last_warning_time = 0;

          // Critical overheating - immediate shutdown
          if (x > 85.0) {
            ESP_LOGW("thermal", "CRITICAL: ESP32 overheating: %.1fÂ°C - initiating emergency shutdown", x);
            id(last_fault_type) = "THERMAL_CRITICAL";
            id(fault_count)++;
            id(thermal_shutdown).execute();
            return x;
          }

          // High temperature warning - multiple stages
          if (x > 75.0) {
            high_temp_count++;

            // Persistent high temperature
            if (high_temp_count > 12) { // ~3 minutes of elevated temperature
              ESP_LOGW("thermal", "WARNING: ESP32 persistent high temperature: %.1fÂ°C - preventive shutdown", x);
              id(last_fault_type) = "THERMAL_PERSISTENT";
              id(fault_count)++;
              id(thermal_shutdown).execute();
              return x;
            }

            // Repeated warnings at 1 minute intervals
            if (millis() - last_warning_time > 60000) {
              ESP_LOGW("thermal", "WARNING: ESP32 temperature elevated: %.1fÂ°C - monitoring", x);
              last_warning_time = millis();
            }
          } else {
            // Temperature normal - reset counter
            high_temp_count = 0;
          }

          return x;

# Binary sensors for detection and control
binary_sensor:
  # Rodent detection state
  - platform: template
    name: "Rodent Detected"
    id: rodent_detected
    icon: "mdi:rat"
    device_class: motion

  # Trap triggered state
  - platform: template
    name: "Trap Triggered"
    id: trap_triggered
    icon: "mdi:power"

  # Physical reset button (GPIO18)
  - platform: gpio
    pin:
      number: 18
      mode: INPUT_PULLUP
      inverted: true
    name: "Reset Button"
    id: reset_button
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log: "Reset button pressed - restarting system"
      - delay: 1s
      - button.press: restart_button

  # Test trigger functionality moved to software trigger in Home Assistant

  # Optional PIR Motion Sensor (HC-SR501) for pre-detection
  # Add this component to provide early detection and power saving
  - platform: gpio
    pin:
      number: 13  # Adjust GPIO as needed
      mode: INPUT
    name: "PIR Motion Sensor"
    id: pir_sensor
    device_class: motion
    filters:
      - delayed_off: 30s
    on_press:
      then:
        - logger.log: "PIR detected motion - activating enhanced monitoring"
        - script.execute: activate_enhanced_monitoring

# Physical switches and controls
switch:
  # Main vacuum relay control (GPIO5) - Enhanced with 4N35 optocoupler protection
  # Double isolation: ESP32 â†’ 4N35 Optocoupler â†’ SSR â†’ AC Load (>8000V total isolation)
  - platform: gpio
    pin: 5
    name: "Vacuum Relay"
    id: vacuum_relay
    icon: "mdi:vacuum"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log:
          format: "SSR activated - switching %s load (%s compliant)"
          args: ['id(line_voltage).c_str()', 'id(safety_standard).c_str()']
    on_turn_off:
      - logger.log: "SSR deactivated - load disconnected"

  # Software manual trigger
  - platform: template
    name: "Manual Trigger"
    id: manual_trigger
    icon: "mdi:play-circle"
    turn_on_action:
      - if:
          condition:
            binary_sensor.is_off: trap_triggered
          then:
            - logger.log: "Software manual trigger activated"
            - switch.turn_on: vacuum_relay
            - delay: 3s
            - switch.turn_off: vacuum_relay
            # Update vacuum runtime for manual activations too
            - lambda: |-
                float runtime_minutes = 3.0 / 60.0;
                id(total_vacuum_runtime) += runtime_minutes;
                id(vacuum_runtime_sensor).publish_state(id(total_vacuum_runtime));
          else:
            - logger.log: "Manual trigger ignored - system disabled or busy"

  # Power-saving mode control
  - platform: template
    name: "Power Saving Mode"
    id: power_saving_mode
    icon: "mdi:battery-10"
    optimistic: true
    restore_value: true
    turn_on_action:
      - logger.log: "Power saving mode enabled - using PIR for initial detection"
    turn_off_action:
      - logger.log: "Power saving mode disabled - continuous monitoring active"

# Restart button
button:
  - platform: restart
    name: "Restart ESP32"
    id: restart_button

  # Enhanced thermal shutdown protection
  - platform: template
    name: "Thermal Shutdown"
    id: thermal_shutdown
    on_press:
      - logger.log: "THERMAL SHUTDOWN INITIATED - ESP32 overheating detected"
      - switch.turn_off: vacuum_relay
      # Record fault occurrence to persistent storage
      - lambda: |-
          if (id(last_fault_type) == "") {
            id(last_fault_type) = "THERMAL_EMERGENCY";
          }
          id(fault_count_sensor).publish_state(id(fault_count));
          id(last_fault_type_sensor).publish_state(id(last_fault_type));
      - deep_sleep.enter: emergency_sleep

  # System diagnostic tool
  - platform: template
    name: "Run Diagnostics"
    id: run_diagnostics
    on_press:
      - logger.log: "Running system diagnostics..."
      # Basic system checks
      - lambda: |-
          bool system_ok = true;
          std::string diagnostic_results = "";

          // Check I2C devices
          if (i2c::global_i2c_bus->scan_device(0x29) == false) {
            system_ok = false;
            diagnostic_results += "VL53L0X sensor not detected. ";
          }
          if (i2c::global_i2c_bus->scan_device(0x3C) == false) {
            system_ok = false;
            diagnostic_results += "OLED display not detected. ";
          }

          // Check WiFi
          if (!wifi::global_wifi_component->is_connected()) {
            diagnostic_results += "WiFi not connected. ";
          }

          // Check thermal status
          if (id(esp32_temp).state > 70.0) {
            system_ok = false;
            diagnostic_results += "Temperature high: " + to_string(id(esp32_temp).state) + "C. ";
          }

          // Log results
          if (system_ok) {
            ESP_LOGI("diagnostics", "System diagnostics passed");
          } else {
            ESP_LOGW("diagnostics", "System diagnostics failed: %s", diagnostic_results.c_str());
            id(last_fault_type) = "DIAGNOSTICS: " + diagnostic_results;
            id(fault_count)++;
            id(fault_count_sensor).publish_state(id(fault_count));
            id(last_fault_type_sensor).publish_state(id(last_fault_type));
          }
      - logger.log: "Diagnostics complete"

# REMOVED: LED indicators (functionality integrated into OLED display)

# REMOVED: Separate LED indicators (replaced with integrated OLED status display and illuminated E-stop)
# Status display integration using OLED

# Enhanced OLED Display with Integrated Status (Replaces separate LEDs)
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    update_interval: 1s
    lambda: |-
      // Header with voltage-specific system status
      it.printf(0, 0, id(font_small), "Rat Trap %s %s", id(line_voltage).c_str(), id(safety_standard).c_str());

      // WiFi status indicator
      if (id(wifi_component).is_connected()) {
        it.printf(105, 0, id(font_small), "WiFi");
      } else {
        it.printf(100, 0, id(font_small), "No Net");
      }

      // Current distance reading
      it.printf(0, 12, id(font_medium), "Distance: %.0fmm", id(trap_distance).state);

      // System status with visual highlighting (replaces LEDs)
      if (id(trap_triggered).state) {
        // Vacuum running - equivalent to red LED strobe
        it.filled_rectangle(0, 26, 128, 16, COLOR_ON);
        it.print(2, 30, id(font_medium), COLOR_OFF, ">> VACUUM ON <<");
      } else if (id(rodent_detected).state) {
        // Rodent detected - equivalent to red LED alert
        it.rectangle(0, 26, 128, 16, COLOR_ON);
        it.print(2, 30, id(font_medium), "* RODENT ALERT *");
      } else {
        // System armed and monitoring
        it.print(0, 28, id(font_small), "Armed & Monitoring");
        it.print(120, 28, id(font_small), "â—");  // Status dot
      }

      // Capture statistics
      it.printf(0, 42, id(font_small), "Captures: %.0f", id(capture_count_sensor).state);

      // Environmental data from BME280
      if (id(env_temperature).has_state()) {
        it.printf(0, 47, id(font_small), "Env: %.1fÂ°C  %.0f%%RH",
                 id(env_temperature).state, id(env_humidity).state);
      }

      // System monitoring
      if (id(wifi_signal).has_state()) {
        it.printf(0, 56, id(font_small), "WiFi: %.0fdBm  CPU: %.1fÂ°C",
                  id(wifi_signal).state, id(esp32_temp).state);
      } else {
        it.printf(0, 56, id(font_small), "ESP32 Temp: %.1fÂ°C", id(esp32_temp).state);
      }

      // Thermal warning indicator
      if (id(esp32_temp).has_state() && id(esp32_temp).state > 75.0) {
        it.print(120, 56, id(font_small), "!");  // Temperature warning
      }

      // Current monitoring (if ACS712 sensor is installed)
      if (id(vacuum_current).has_state()) {
        it.printf(0, 56, id(font_small), "Vacuum: %.1fA", id(vacuum_current).state);
      }

      // PIR motion indicator (if HC-SR501 sensor is installed)
      if (id(pir_sensor).state) {
        it.print(115, 56, id(font_small), "â—¯");  // Motion indicator
      }

# Fonts for display
font:
  - file: "gfonts://Roboto Mono"
    id: font_small
    size: 8
  - file: "gfonts://Roboto Mono"
    id: font_medium
    size: 12

# Global variables for state tracking
globals:
  - id: capture_count
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_trigger_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: total_vacuum_runtime
    type: float
    restore_value: yes
    initial_value: '0'

  - id: fault_count
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_fault_type
    type: std::string
    restore_value: yes
    initial_value: '""'

  - id: enhanced_monitoring_active
    type: bool
    restore_value: no
    initial_value: 'false'

# Script for PIR-based enhanced monitoring
script:
  - id: activate_enhanced_monitoring
    then:
      - lambda: 'id(enhanced_monitoring_active) = true;'
      - logger.log: "Enhanced monitoring mode activated"
      # Increase sensor polling rate when motion is detected
      - sensor.template.publish:
          id: trap_distance
          state: !lambda 'return id(trap_distance).state;'
      # After 30 seconds, return to normal operation
      - delay: 30s
      - lambda: 'id(enhanced_monitoring_active) = false;'
      - logger.log: "Returning to normal monitoring"

# System startup and compliance monitoring
interval:
  # Safety-critical power-on sequence per NEC 422.31(B)
  - interval: 5s
    then:
      - if:
          condition:
            lambda: 'return millis() < 5000;'  # First 5 seconds after boot
          then:
            # NEC 422.31(B): Ensure SSR is OFF during power-up (safety critical)
            - switch.turn_off: vacuum_relay
            - logger.log:
                format: "Power-on sequencing: SSR disabled during boot (%s compliance)"
                args: ['id(safety_standard).c_str()']

  # NEC/IEC compliance monitoring
  - interval: 60s
    then:
      - lambda: |-
          // Log safety compliance status
          ESP_LOGI("safety", "System running %s compliant at %s %s",
                   id(safety_standard).c_str(),
                   id(line_voltage).c_str(),
                   id(line_frequency).c_str());

# Emergency sleep mode for thermal protection
deep_sleep:
  id: emergency_sleep
  sleep_duration: 60s  # Cool down period

# REMOVED: LED control automations (functionality integrated into OLED display)
# Simplified automation focused on core safety and functionality

# Web server for local configuration
web_server:
  port: 80
  version: 2
  include_internal: true

# Status indication integrated into OLED display

# System information with voltage specifications
text_sensor:
  - platform: template
    name: "System Voltage"
    id: system_voltage
    lambda: 'return {"${line_voltage}"};'

  - platform: template
    name: "Line Frequency"
    id: system_frequency
    lambda: 'return {"${line_frequency}"};'

  - platform: template
    name: "Safety Standard"
    id: system_safety_standard
    lambda: 'return {"${safety_standard}"};'

  - platform: template
    name: "Max Current Rating"
    id: max_current_rating
    lambda: 'return {"${max_current}"};'

  - platform: wifi_info
    ip_address:
      name: "IP Address"
      id: ip_address
    ssid:
      name: "Connected SSID"
      id: wifi_ssid
    mac_address:
      name: "MAC Address"
      id: mac_address

  - platform: version
    name: "ESPHome Version"

  # Fault type reporting
  - platform: template
    name: "Last Fault Type"
    id: last_fault_type_sensor
    icon: "mdi:alert-circle"
    lambda: |-
      return id(last_fault_type);

# Configurable parameters for easy tuning
number:
  - platform: template
    name: "Detection Threshold (mm)"
    id: detection_threshold
    min_value: 50
    max_value: 500
    step: 10
    initial_value: 150
    restore_value: true
    optimistic: true

  - platform: template
    name: "Vacuum Runtime (seconds)"
    id: vacuum_runtime
    min_value: 1
    max_value: 30
    step: 1
    initial_value: 8
    restore_value: true
    optimistic: true

  - platform: template
    name: "Cooldown Period (seconds)"
    id: cooldown_period
    min_value: 10
    max_value: 300
    step: 5
    initial_value: 30
    restore_value: true
    optimistic: true

# EOF - End of ESPHome configuration
#
# COMPLIANCE IMPROVEMENTS:
# - NEC Article 422 appliance switching compliance
# - IEC 60204-1 machinery safety standard compliance
# - Enhanced thermal monitoring with automatic shutdown
# - Voltage-specific configurations for global deployment
# - EMI compliance (FCC Part 15 / EN 55011 Class B)
# - Mandatory GFCI/RCD protection for wet locations

```
