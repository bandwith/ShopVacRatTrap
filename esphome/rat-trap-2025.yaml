---
esphome:
  name: rat-trap-2025
  friendly_name: ShopVac Rat Trap 2025
  comment: NEC/IEC compliant ESP32-S3 based rat trap with STEMMA QT hybrid detection system

# ESP32-S3 Feather configuration - Standard hybrid detection variant
esp32:
  board: adafruit_feather_esp32s3
  variant: esp32s3
  framework:
    type: arduino

# Voltage-specific configuration (uncomment appropriate section)
substitutions:
  # ðŸ‡ºðŸ‡¸ North America (120V AC, 60Hz, NEC compliant)
  line_voltage: 120V AC
  line_frequency: 60Hz
  max_current: 15A
  safety_standard: NEC/UL

  # ðŸ‡ªðŸ‡º Europe (230V AC, 50Hz, IEC/CE compliant)
  # line_voltage: "230V AC"
  # line_frequency: "50Hz"
  # max_current: "10A"
  # safety_standard: "IEC/CE"

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: RatTrap2025 Fallback
    password: !secret ap_password

captive_portal:

# I2C bus configuration for hybrid detection sensors via STEMMA QT
# Standard configuration uses STEMMA QT daisy chain for easy assembly
# Primary sensors: APDS9960 + VL53L0X + BME280 + OLED display
i2c:
  - id: bus_a
    sda: 3   # ESP32-S3 Feather STEMMA QT SDA
    scl: 4   # ESP32-S3 Feather STEMMA QT SCL
    scan: true
    frequency: 100kHz   # Reduced for EMI immunity in high-voltage environment

# Hybrid detection sensor configuration - Standard STEMMA QT sensors
sensor:
  # APDS9960 Proximity/Light/Gesture Sensor - PRIMARY detection sensor
  - platform: apds9960
    address: 0x39
    update_interval: 100ms   # Fast for responsive detection
    proximity:
      name: APDS9960 Proximity
      id: apds_proximity
      filters:
        - sliding_window_moving_average:
            window_size: 5
            send_every: 3

  # VL53L0X Time-of-Flight sensor - SECONDARY confirmation sensor
  - platform: vl53l0x
    name: ToF Distance
    id: tof_distance
    address: 0x29
    update_interval: 100ms
    long_range: true
    filters:
      - median:
          window_size: 5
          send_every: 2
      - sliding_window_moving_average:
          window_size: 8
          send_every: 3
      - lambda: |-
          // Reject obviously bad readings
          if (x > 2000 || x < 10) return {};
          return x;

  # BME280 environmental sensor via STEMMA QT (I2C)
  - platform: bme280_i2c
    address: 0x77   # Adafruit STEMMA QT BME280 default address
    temperature:
      name: Environmental Temperature
      id: env_temperature
      accuracy_decimals: 1
      filters:
        - sliding_window_moving_average:
            window_size: 5
            send_every: 5
      unit_of_measurement: Â°C
      device_class: temperature
      state_class: measurement
    humidity:
      name: Environmental Humidity
      id: env_humidity
      accuracy_decimals: 0
      unit_of_measurement: '%'
      device_class: humidity
      state_class: measurement
    pressure:
      name: Barometric Pressure
      id: env_pressure
      accuracy_decimals: 1
      unit_of_measurement: hPa
      device_class: atmospheric_pressure
      state_class: measurement
    update_interval: 60s

  # Hybrid detection trigger - Template sensor for multi-sensor confirmation
  - platform: template
    name: Detection Confidence
    id: detection_confidence
    unit_of_measurement: sensors
    accuracy_decimals: 0
    lambda: |-
      int detection_count = 0;

      // APDS9960 proximity detection
      if (id(apds_proximity).state > 50) detection_count++;

      // VL53L0X distance detection
      if (id(tof_distance).state < id(detection_threshold).state) detection_count++;

      // PIR motion detection
      if (id(pir_motion).is_on()) detection_count++;

      return detection_count;
    on_value:
      - if:
          condition:
            and:
              - lambda: return x >= 2;           # Require 2 of 3 sensors
              - binary_sensor.is_off: trap_triggered
              - lambda: return (millis() - id(last_trigger_time) > (id(cooldown_period).state * 1000));
          then:
            - logger.log: Hybrid detection confirmed - 2+ sensors triggered
            - script.execute: activate_trap_sequence

  # Capture count tracker with persistence
  - platform: template
    name: Capture Count
    id: capture_count_sensor
    icon: mdi:counter
    accuracy_decimals: 0
    state_class: total_increasing
    lambda: |-
      return id(capture_count);

  # Vacuum runtime tracking for maintenance scheduling
  - platform: template
    name: Total Vacuum Runtime
    id: vacuum_runtime_sensor
    icon: mdi:vacuum
    unit_of_measurement: minutes
    accuracy_decimals: 1
    device_class: duration
    state_class: total_increasing
    lambda: |-
      return id(total_vacuum_runtime);

  # ESP32 internal temperature monitoring with enhanced thermal management
  - platform: template
    name: ESP32 Temperature
    id: esp32_temp
    icon: mdi:thermometer
    unit_of_measurement: Â°C
    device_class: temperature
    state_class: measurement
    lambda: |-
      return temperatureRead();
    update_interval: 15s
    filters:
      - sliding_window_moving_average:
          window_size: 4
          send_every: 2
      - lambda: |-
          // Enhanced thermal protection
          if (x > 85.0) {
            ESP_LOGW("thermal", "CRITICAL: ESP32 overheating: %.1fÂ°C - initiating emergency shutdown", x);
            id(last_fault_type) = "THERMAL_CRITICAL";
            id(fault_count)++;
            id(thermal_shutdown_button).press();
            return x;
          }
          if (x > 75.0) {
            ESP_LOGW("thermal", "WARNING: ESP32 temperature elevated: %.1fÂ°C", x);
          }
          return x;

  # System fault monitoring
  - platform: template
    name: Fault Count
    id: fault_count_sensor
    icon: mdi:alert
    accuracy_decimals: 0
    state_class: total_increasing
    lambda: |-
      return id(fault_count);

  # System monitoring sensors
  - platform: wifi_signal
    name: WiFi Signal Strength
    id: wifi_signal
    update_interval: 60s

  - platform: uptime
    name: System Uptime
    id: uptime_sensor

# Binary sensors for hybrid detection system
binary_sensor:
  # PIR Motion Sensor - TERTIARY detection sensor (HC-SR501 STEMMA JST PH)
  - platform: gpio
    name: PIR Motion Detected
    id: pir_motion
    pin:
      number: GPIO13
      mode: INPUT_PULLDOWN
    filters:
      - delayed_on: 10ms     # Debounce
      - delayed_off: 2000ms     # Keep active for 2 seconds

  # Rodent detection state (triggered by hybrid sensor confirmation)
  - platform: template
    name: Rodent Detected
    id: rodent_detected
    icon: mdi:rat
    device_class: motion

  # Trap triggered state
  - platform: template
    name: Trap Triggered
    id: trap_triggered
    icon: mdi:power

  # Emergency stop switch (GPIO18 - Safety critical)
  - platform: gpio
    pin:
      number: 18
      mode: INPUT_PULLUP
      inverted: true
    name: Emergency Stop
    id: emergency_stop
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log: EMERGENCY STOP ACTIVATED - All operations halted
      - switch.turn_off: vacuum_relay
      - binary_sensor.template.publish:
          id: trap_triggered
          state: off
      - lambda: id(system_armed) = false;

  # Reset button (GPIO10)
  - platform: gpio
    pin:
      number: 10
      mode: INPUT_PULLUP
      inverted: true
    name: Reset Button
    id: reset_button
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log: Reset button pressed - restarting system
      - delay: 1s
      - button.press: restart_button

# Physical switches and controls
switch:
  # Main vacuum relay control (GPIO5) - Enhanced with optocoupler isolation
  # Safety critical: ESP32 â†’ 4N35 Optocoupler â†’ SSR â†’ AC Load
  - platform: gpio
    pin: 5
    name: Vacuum Relay
    id: vacuum_relay
    icon: mdi:vacuum
    restore_mode: ALWAYS_OFF   # Safety: Always start with vacuum OFF
    on_turn_on:
      - logger.log:
          format: SSR activated - switching %s load (%s compliant)
          args: ['${line_voltage}', '${safety_standard}']
    on_turn_off:
      - logger.log: SSR deactivated - load disconnected

  # Software manual trigger
  - platform: template
    name: Manual Trigger
    id: manual_trigger
    icon: mdi:play-circle
    turn_on_action:
      - if:
          condition:
            and:
              - binary_sensor.is_off: trap_triggered
              - binary_sensor.is_off: emergency_stop
          then:
            - logger.log: Manual trigger activated
            - script.execute: activate_trap_sequence
          else:
            - logger.log: Manual trigger ignored - system disabled or emergency stop active

  # System arming control
  - platform: template
    name: System Armed
    id: system_armed_switch
    icon: mdi:shield-check
    optimistic: true
    restore_value: true
    turn_on_action:
      - logger.log: System armed - hybrid detection active
      - lambda: id(system_armed) = true;
    turn_off_action:
      - logger.log: System disarmed - detection disabled
      - lambda: id(system_armed) = false;

# Control scripts for trap operation
script:
  # Main trap activation sequence
  - id: activate_trap_sequence
    mode: single
    then:
      - if:
          condition:
            and:
              - lambda: return id(system_armed);
              - binary_sensor.is_off: emergency_stop
              - binary_sensor.is_off: trap_triggered
          then:
            - logger.log: Trap sequence initiated - hybrid detection confirmed
            - binary_sensor.template.publish:
                id: rodent_detected
                state: on
            - binary_sensor.template.publish:
                id: trap_triggered
                state: on
            - switch.turn_on: vacuum_relay
            - lambda: id(last_trigger_time) = millis();
            - delay: !lambda 'return id(vacuum_runtime).state * 1000;'
            - switch.turn_off: vacuum_relay
            - lambda: |-
                // Update capture statistics
                id(capture_count) += 1;
                id(capture_count_sensor).publish_state(id(capture_count));

                // Update vacuum runtime tracking
                float runtime_minutes = id(vacuum_runtime).state / 60.0;
                id(total_vacuum_runtime) += runtime_minutes;
                id(vacuum_runtime_sensor).publish_state(id(total_vacuum_runtime));
            - delay: 2s
            - binary_sensor.template.publish:
                id: trap_triggered
                state: off
            - delay: !lambda 'return id(cooldown_period).state * 1000;'
            - binary_sensor.template.publish:
                id: rodent_detected
                state: off
            - logger.log: Trap sequence complete - system re-armed
          else:
            - logger.log: Trap sequence blocked - system disarmed or emergency stop active

  # Thermal shutdown script
  - id: thermal_shutdown
    mode: single
    then:
      - logger.log: THERMAL SHUTDOWN ACTIVATED
      - switch.turn_off: vacuum_relay
      - binary_sensor.template.publish:
          id: trap_triggered
          state: off
      - lambda: |-
          id(system_armed) = false;
      - deep_sleep.enter:
          id: emergency_sleep
          sleep_duration: 300s       # 5 minute cooldown

# Control buttons
button:
  - platform: restart
    name: Restart ESP32
    id: restart_button

  # Thermal shutdown button (software controlled)
  - platform: template
    name: Thermal Shutdown
    id: thermal_shutdown_button
    on_press:
      - script.execute: thermal_shutdown

  # System diagnostic tool
  - platform: template
    name: Run Diagnostics
    id: run_diagnostics
    on_press:
      - logger.log: Running system diagnostics...
      - lambda: |-
          bool system_ok = true;
          std::string diagnostic_results = "";

          // Check I2C devices
          ESP_LOGI("diagnostics", "Checking I2C devices...");
          if (!id(apds_proximity).has_state()) {
            system_ok = false;
            diagnostic_results += "APDS9960 sensor not responding. ";
          }
          if (!id(tof_distance).has_state()) {
            system_ok = false;
            diagnostic_results += "VL53L0X ToF sensor not responding. ";
          }
          if (!id(env_temperature).has_state()) {
            system_ok = false;
            diagnostic_results += "BME280 environmental sensor not responding. ";
          }

          // Check thermal status
          if (id(esp32_temp).state > 70.0) {
            system_ok = false;
            diagnostic_results += "Temperature high: " + to_string(id(esp32_temp).state) + "C. ";
          }

          // Log results
          if (system_ok) {
            ESP_LOGI("diagnostics", "System diagnostics passed");
            id(last_fault_type) = "DIAGNOSTICS_PASSED";
          } else {
            ESP_LOGW("diagnostics", "System diagnostics failed: %s", diagnostic_results.c_str());
            id(last_fault_type) = "DIAGNOSTICS: " + diagnostic_results;
            id(fault_count)++;
            id(fault_count_sensor).publish_state(id(fault_count));
          }
          id(last_fault_type_sensor).publish_state(id(last_fault_type));
      - logger.log: Diagnostics complete

# Global variables for state tracking
globals:
  - id: capture_count
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_trigger_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: total_vacuum_runtime
    type: float
    restore_value: yes
    initial_value: '0'

  - id: fault_count
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_fault_type
    type: std::string
    restore_value: yes
    initial_value: '""'

  - id: system_armed
    type: bool
    restore_value: no
    initial_value: 'true'

# Configurable parameters for easy tuning
number:
  - platform: template
    name: Detection Threshold (mm)
    id: detection_threshold
    min_value: 50
    max_value: 500
    step: 10
    initial_value: 150
    restore_value: true
    optimistic: true

  - platform: template
    name: Vacuum Runtime (seconds)
    id: vacuum_runtime
    min_value: 1
    max_value: 30
    step: 1
    initial_value: 8
    restore_value: true
    optimistic: true

  - platform: template
    name: Cooldown Period (seconds)
    id: cooldown_period
    min_value: 10
    max_value: 300
    step: 5
    initial_value: 30
    restore_value: true
    optimistic: true

# System information sensors
text_sensor:
  - platform: template
    name: System Voltage
    id: system_voltage
    lambda: return {"${line_voltage}"};

  - platform: template
    name: Line Frequency
    id: system_frequency
    lambda: return {"${line_frequency}"};

  - platform: template
    name: Safety Standard
    id: system_safety_standard
    lambda: return {"${safety_standard}"};

  - platform: template
    name: Max Current Rating
    id: max_current_rating
    lambda: return {"${max_current}"};

  - platform: wifi_info
    ip_address:
      name: IP Address
      id: ip_address
    ssid:
      name: Connected SSID
      id: wifi_ssid
    mac_address:
      name: MAC Address
      id: mac_address

  - platform: version
    name: ESPHome Version

  # Fault type reporting
  - platform: template
    name: Last Fault Type
    id: last_fault_type_sensor
    icon: mdi:alert-circle
    lambda: |-
      return id(last_fault_type);

# Deep sleep for thermal protection
deep_sleep:
  id: emergency_sleep
  sleep_duration: 300s   # 5 minute cooldown

# Safety-critical startup sequence per NEC 422.31(B)
interval:
  - interval: 5s
    then:
      - if:
          condition:
            lambda: return millis() < 5000;         # First 5 seconds after boot
          then:
            # NEC 422.31(B): Ensure SSR is OFF during power-up (safety critical)
            - switch.turn_off: vacuum_relay
            - logger.log:
                format: 'Power-on sequencing: SSR disabled during boot (%s compliance)'
                args: ['${safety_standard}']

  # NEC/IEC compliance monitoring
  - interval: 60s
    then:
      - lambda: |-
          // Log safety compliance status
          ESP_LOGI("safety", "System running %s compliant at %s %s",
                   "${safety_standard}",
                   "${line_voltage}",
                   "${line_frequency}");

# Web server for local configuration
web_server:
  port: 80
  version: 2
  include_internal: true

# OLED Display with Integrated Status (STEMMA QT)
display:
  - platform: ssd1306_i2c
    model: SSD1306 128x64
    address: 0x3C
    update_interval: 1s
    lambda: |-
      // Header with voltage-specific system status
      it.printf(0, 0, id(font_small), "Rat Trap %s %s", "${line_voltage}", "${safety_standard}");

      // WiFi status indicator (top right)
      if (id(wifi_component).is_connected()) {
        it.printf(105, 0, id(font_small), "WiFi");
      } else {
        it.printf(100, 0, id(font_small), "No Net");
      }

      // Hybrid detection sensor status
      it.printf(0, 12, id(font_medium), "Hybrid Detection:");

      // Sensor status indicators (3 sensors)
      int y_offset = 26;
      if (id(apds_proximity).state > 50) {
        it.printf(0, y_offset, id(font_small), "âœ“ APDS");
      } else {
        it.printf(0, y_offset, id(font_small), "â—‹ APDS");
      }

      if (id(tof_distance).state < id(detection_threshold).state) {
        it.printf(40, y_offset, id(font_small), "âœ“ ToF");
      } else {
        it.printf(40, y_offset, id(font_small), "â—‹ ToF");
      }

      if (id(pir_motion).state) {
        it.printf(70, y_offset, id(font_small), "âœ“ PIR");
      } else {
        it.printf(70, y_offset, id(font_small), "â—‹ PIR");
      }

      // System status with visual highlighting
      y_offset += 12;
      if (id(emergency_stop).state) {
        it.filled_rectangle(0, y_offset, 128, 12, COLOR_ON);
        it.print(2, y_offset + 2, id(font_small), COLOR_OFF, ">> EMERGENCY STOP <<");
      } else if (id(trap_triggered).state) {
        it.filled_rectangle(0, y_offset, 128, 12, COLOR_ON);
        it.print(2, y_offset + 2, id(font_small), COLOR_OFF, ">> VACUUM ACTIVE <<");
      } else if (id(rodent_detected).state) {
        it.rectangle(0, y_offset, 128, 12, COLOR_ON);
        it.print(2, y_offset + 2, id(font_small), "* DETECTION ALERT *");
      } else if (id(system_armed)) {
        it.print(0, y_offset + 2, id(font_small), "Armed & Monitoring");
        it.print(120, y_offset + 2, id(font_small), "â—");
      } else {
        it.print(0, y_offset + 2, id(font_small), "System Disarmed");
      }

      // Capture statistics
      it.printf(0, 54, id(font_small), "Captures: %.0f  Temp: %.1fÂ°C",
                id(capture_count_sensor).state, id(esp32_temp).state);

      // Thermal warning indicator
      if (id(esp32_temp).has_state() && id(esp32_temp).state > 75.0) {
        it.print(120, 56, id(font_small), "!");
      }

# Fonts for display
font:
  - file: gfonts://Roboto Mono
    id: font_small
    size: 8
  - file: gfonts://Roboto Mono
    id: font_medium
    size: 12

# EOF - End of ESPHome configuration
#
# COMPLIANCE IMPROVEMENTS:
# - NEC Article 422 appliance switching compliance
# - IEC 60204-1 machinery safety standard compliance
# - Enhanced thermal monitoring with automatic shutdown
# - Voltage-specific configurations for global deployment
# - EMI compliance (FCC Part 15 / EN 55011 Class B)
# - Mandatory GFCI/RCD protection for wet locations
