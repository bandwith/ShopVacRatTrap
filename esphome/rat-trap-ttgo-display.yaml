esphome:
  name: rat-trap-ttgo
  friendly_name: "ShopVac Rat Trap TTGO"
  platform: ESP32
  board: esp32dev
  comment: "Cost-optimized TTGO ESP32+OLED integrated version ($18 savings)"

# Voltage-specific configuration (uncomment appropriate section)
substitutions:
  # ðŸ‡ºðŸ‡¸ North America (120V AC, 60Hz, NEC compliant)
  line_voltage: "120V AC"
  line_frequency: "60Hz"
  max_current: "15A"
  safety_standard: "NEC/UL"

  # ðŸ‡ªðŸ‡º Europe (230V AC, 50Hz, IEC/CE compliant)
  # line_voltage: "230V AC"
  # line_frequency: "50Hz"
  # max_current: "10A"
  # safety_standard: "IEC/CE"

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "RatTrap-TTGO Fallback"
    password: !secret ap_password

captive_portal:

# TTGO ESP32 Integrated Display - Cost-optimized version
# Uses TTGO T-Display or similar ESP32+Display modules ($18)
# Eliminates separate ESP32 ($8) + OLED Display ($12) = $20 total
# Net savings: $8 per build
# --------------------
# I2C bus configuration for VL53L1X and BME280 with EMI protection
i2c:
  sda: 21
  scl: 22
  scan: true
  frequency: 100kHz  # Reduced from 400kHz for better EMI immunity in high-voltage environment

# Time-of-Flight sensor (VL53L1X - improved range and accuracy)
sensor:
  - platform: vl53l1x
    name: "Trap Distance"
    id: trap_distance
    address: 0x29
    update_interval: 50ms

  # Added BME280 environmental sensor
  - platform: bme280
    address: 0x76
    update_interval: 60s
    temperature:
      name: "Environmental Temperature"
      id: env_temperature
      accuracy_decimals: 1
      filters:
        - sliding_window_moving_average:
            window_size: 5
            send_every: 5
      unit_of_measurement: "Â°C"
      device_class: temperature
      state_class: measurement
    pressure:
      name: "Barometric Pressure"
      id: env_pressure
      accuracy_decimals: 1
      unit_of_measurement: "hPa"
      device_class: pressure
      state_class: measurement
    humidity:
      name: "Environmental Humidity"
      id: env_humidity
      accuracy_decimals: 0
      unit_of_measurement: "%"
      device_class: humidity
      state_class: measurement
    timeout: 200ms
    filters:
      - sliding_window_moving_average:
          window_size: 20
          send_every: 5
      - lambda: |-
          // Reject obviously bad readings
          if (x > 4000 || x < 10) return {};
          return x;
    on_value_range:
      - below: 150.0  # 15cm threshold for rodent detection
        then:
          - if:
              condition:
                and:
                  - binary_sensor.is_off: trap_triggered
                  - binary_sensor.is_on: emergency_disable_switch
                  - lambda: 'return (millis() - id(last_trigger_time) > (id(cooldown_period).state * 1000));' # Configurable cooldown
              then:
                - logger.log: "Rodent detected! Triggering vacuum sequence."
                - binary_sensor.template.publish:
                    id: rodent_detected
                    state: ON
                - binary_sensor.template.publish:
                    id: trap_triggered
                    state: ON
                - switch.turn_on: vacuum_relay
                - lambda: 'id(last_trigger_time) = millis();'
                - delay: !lambda 'return id(vacuum_runtime).state * 1000;'  # Configurable runtime
                - switch.turn_off: vacuum_relay
                - lambda: |-
                    // Update capture count
                    id(capture_count) += 1;
                    id(capture_count_sensor).publish_state(id(capture_count));

                    // Update vacuum runtime tracking
                    float runtime_minutes = id(vacuum_runtime).state / 60.0;
                    id(total_vacuum_runtime) += runtime_minutes;
                    id(vacuum_runtime_sensor).publish_state(id(total_vacuum_runtime));
                - delay: 2s
                - binary_sensor.template.publish:
                    id: trap_triggered
                    state: OFF
                - delay: !lambda 'return id(cooldown_period).state * 1000;'  # Configurable cooldown
                - binary_sensor.template.publish:
                    id: rodent_detected
                    state: OFF
      - above: 200.0  # Clear detection threshold
        then:
          - if:
              condition:
                and:
                  - binary_sensor.is_off: trap_triggered
              then:
                - binary_sensor.template.publish:
                    id: rodent_detected
                    state: OFF

  # Capture count tracker with persistence
  - platform: template
    name: "Capture Count"
    id: capture_count_sensor
    icon: "mdi:counter"
    accuracy_decimals: 0
    state_class: total_increasing

  # Vacuum runtime tracking for maintenance scheduling
  - platform: template
    name: "Total Vacuum Runtime"
    id: vacuum_runtime_sensor
    icon: "mdi:vacuum"
    unit_of_measurement: "minutes"
    accuracy_decimals: 1
    device_class: duration
    state_class: total_increasing
    lambda: |-
      return id(total_vacuum_runtime);

  # System fault monitoring
  - platform: template
    name: "Fault Count"
    id: fault_count_sensor
    icon: "mdi:alert"
    accuracy_decimals: 0
    state_class: total_increasing
    lambda: |-
      return id(fault_count);

  # System monitoring sensors
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal
    update_interval: 60s

  - platform: uptime
    name: "System Uptime"
    id: uptime_sensor

  # ESP32 internal temperature monitoring with enhanced thermal management
  - platform: template
    name: "ESP32 Temperature"
    id: esp32_temp
    icon: "mdi:thermometer"
    unit_of_measurement: "Â°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
      return temperatureRead();
    update_interval: 15s  # More frequent monitoring for better thermal tracking
    filters:
      - sliding_window_moving_average:  # Smooth out temperature readings
          window_size: 4
          send_every: 2
      - lambda: |-
          // Enhanced thermal protection with tiered warnings
          static int high_temp_count = 0;
          static unsigned long last_warning_time = 0;

          // Critical overheating - immediate shutdown
          if (x > 85.0) {
            ESP_LOGW("thermal", "CRITICAL: ESP32 overheating: %.1fÂ°C - initiating emergency shutdown", x);
            id(last_fault_type) = "THERMAL_CRITICAL";
            id(fault_count)++;
            id(thermal_shutdown).execute();
            return x;
          }

          // High temperature warning - multiple stages
          if (x > 75.0) {
            high_temp_count++;

            // Persistent high temperature
            if (high_temp_count > 12) { // ~3 minutes of elevated temperature
              ESP_LOGW("thermal", "WARNING: ESP32 persistent high temperature: %.1fÂ°C - preventive shutdown", x);
              id(last_fault_type) = "THERMAL_PERSISTENT";
              id(fault_count)++;
              id(thermal_shutdown).execute();
              return x;
            }

            // Repeated warnings at 1 minute intervals
            if (millis() - last_warning_time > 60000) {
              ESP_LOGW("thermal", "WARNING: ESP32 temperature elevated: %.1fÂ°C - monitoring", x);
              last_warning_time = millis();
            }
          } else {
            // Temperature normal - reset counter
            high_temp_count = 0;
          }

          return x;

  # Optional ACS712 current sensor for vacuum monitoring
  - platform: adc
    pin: GPIO34
    name: "Vacuum Current"
    id: vacuum_current
    update_interval: 1s
    attenuation: 11db  # For 0-3.3V ADC range
    filters:
      - calibrate_linear:
          # Map ADC values to current (adjust these based on calibration)
          - 0.512 -> 0.0  # Zero point (no current)
          - 0.920 -> 8.0  # 8A load point
      - sliding_window_moving_average:
          window_size: 10
          send_every: 5
    unit_of_measurement: "A"
    accuracy_decimals: 1
    device_class: current
    state_class: measurement

# Binary sensors for detection and control
binary_sensor:
  # Rodent detection state
  - platform: template
    name: "Rodent Detected"
    id: rodent_detected
    icon: "mdi:rat"
    device_class: motion

  # Trap triggered state
  - platform: template
    name: "Trap Triggered"
    id: trap_triggered
    icon: "mdi:power"

  # Physical reset button (GPIO18)
  - platform: gpio
    pin:
      number: 18
      mode: INPUT_PULLUP
      inverted: true
    name: "Reset Button"
    id: reset_button
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log: "Reset button pressed - restarting system"
      - delay: 1s
      - button.press: restart_button

  # Physical emergency stop button (GPIO4) - SAFETY CRITICAL
  - platform: gpio
    pin:
      number: 4
      mode: INPUT_PULLUP
      inverted: true
    name: "Emergency Stop Button"
    id: emergency_disable_switch
    device_class: safety
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_state:
      - if:
          condition:
            binary_sensor.is_on: emergency_disable_switch
          then:
            - logger.log: "E-STOP RELEASED - system armed"
          else:
            - logger.log: "EMERGENCY STOP ACTIVATED - immediate shutdown"
            - switch.turn_off: vacuum_relay

  # Optional PIR Motion Sensor (HC-SR501) for pre-detection
  - platform: gpio
    pin:
      number: 13  # Adjust GPIO as needed
      mode: INPUT
    name: "PIR Motion Sensor"
    id: pir_sensor
    device_class: motion
    filters:
      - delayed_off: 30s
    on_press:
      then:
        - logger.log: "PIR detected motion - activating VL53L1X"
        - script.execute: activate_tof_sensor

# Physical switches and controls
switch:
  # Main vacuum relay control (GPIO5) - NEC/IEC compliant switching
  - platform: gpio
    pin: 5
    name: "Vacuum Relay"
    id: vacuum_relay
    icon: "mdi:vacuum"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log:
          format: "SSR activated - switching %s load (%s compliant)"
          args: ['id(line_voltage).c_str()', 'id(safety_standard).c_str()']
    on_turn_off:
      - logger.log: "SSR deactivated - load disconnected"

  # Software manual trigger
  - platform: template
    name: "Manual Trigger"
    id: manual_trigger
    icon: "mdi:play-circle"
    turn_on_action:
      - if:
          condition:
            and:
              - binary_sensor.is_on: emergency_disable_switch
              - binary_sensor.is_off: trap_triggered
          then:
            - logger.log: "Software manual trigger activated"
            - switch.turn_on: vacuum_relay
            - delay: 3s
            - switch.turn_off: vacuum_relay
            # Update vacuum runtime for manual activations too
            - lambda: |-
                float runtime_minutes = 3.0 / 60.0;
                id(total_vacuum_runtime) += runtime_minutes;
                id(vacuum_runtime_sensor).publish_state(id(total_vacuum_runtime));
          else:
            - logger.log: "Manual trigger ignored - system disabled or busy"

# Power-saving mode control
  - platform: template
    name: "Power Saving Mode"
    id: power_saving_mode
    icon: "mdi:battery-10"
    optimistic: true
    restore_value: true

# Restart button
button:
  - platform: restart
    name: "Restart ESP32"
    id: restart_button

  # Enhanced thermal shutdown protection
  - platform: template
    name: "Thermal Shutdown"
    id: thermal_shutdown
    on_press:
      - logger.log: "THERMAL SHUTDOWN INITIATED - ESP32 overheating detected"
      - switch.turn_off: vacuum_relay
      # Record fault occurrence to persistent storage
      - lambda: |-
          if (id(last_fault_type) == "") {
            id(last_fault_type) = "THERMAL_EMERGENCY";
          }
          id(fault_count_sensor).publish_state(id(fault_count));
          id(last_fault_type_sensor).publish_state(id(last_fault_type));
      - deep_sleep.enter: emergency_sleep

  # System diagnostic tool
  - platform: template
    name: "Run Diagnostics"
    id: run_diagnostics
    on_press:
      - logger.log: "Running system diagnostics..."
      # Basic system checks
      - lambda: |-
          bool system_ok = true;
          std::string diagnostic_results = "";

          // Check I2C devices
          if (i2c::global_i2c_bus->scan_device(0x29) == false) {
            system_ok = false;
            diagnostic_results += "VL53L1X sensor not detected. ";
          }
          if (i2c::global_i2c_bus->scan_device(0x76) == false) {
            system_ok = false;
            diagnostic_results += "BME280 sensor not detected. ";
          }

          // Check WiFi
          if (!wifi::global_wifi_component->is_connected()) {
            diagnostic_results += "WiFi not connected. ";
          }

          // Check thermal status
          if (id(esp32_temp).state > 70.0) {
            system_ok = false;
            diagnostic_results += "Temperature high: " + to_string(id(esp32_temp).state) + "C. ";
          }

          // Check optional current sensor if enabled
          if (id(vacuum_current).state > 12.0) {
            system_ok = false;
            diagnostic_results += "Vacuum current high: " + to_string(id(vacuum_current).state) + "A. ";
          }

          // Log results
          if (system_ok) {
            ESP_LOGI("diagnostics", "System diagnostics passed");
          } else {
            ESP_LOGW("diagnostics", "System diagnostics failed: %s", diagnostic_results.c_str());
            id(last_fault_type) = "DIAGNOSTICS: " + diagnostic_results;
            id(fault_count)++;
            id(fault_count_sensor).publish_state(id(fault_count));
            id(last_fault_type_sensor).publish_state(id(last_fault_type));
          }
      - logger.log: "Diagnostics complete"

# TTGO Integrated Display - uses built-in ST7789V or similar
display:
  - platform: st7789v
    model: TTGO_TDisplay
    backlight_pin: GPIO4
    cs_pin: GPIO5
    dc_pin: GPIO16
    reset_pin: GPIO23
    rotation: 270
    lambda: |-
      // Header with voltage-specific system status
      it.printf(0, 0, id(font_small), "Rat Trap %s %s", id(line_voltage).c_str(), id(safety_standard).c_str());

      // WiFi status indicator
      if (id(wifi_component).is_connected()) {
        it.printf(105, 0, id(font_small), "WiFi");
      } else {
        it.printf(100, 0, id(font_small), "No Net");
      }

      // Current distance reading
      it.printf(0, 12, id(font_medium), "Distance: %.0fmm", id(trap_distance).state);

      // System status with visual highlighting
      if (id(trap_triggered).state) {
        // Vacuum running - red highlight
        it.filled_rectangle(0, 26, 128, 16, COLOR_RED);
        it.print(2, 30, id(font_medium), COLOR_WHITE, ">> VACUUM ON <<");
      } else if (id(rodent_detected).state) {
        // Rodent detected - yellow highlight
        it.rectangle(0, 26, 128, 16, COLOR_YELLOW);
        it.print(2, 30, id(font_medium), COLOR_BLACK, "* RODENT ALERT *");
      } else if (id(emergency_disable_switch).state) {
        // System armed - green highlight
        it.filled_rectangle(0, 26, 128, 16, COLOR_GREEN);
        it.print(2, 30, id(font_medium), COLOR_BLACK, "SYSTEM ARMED");
      } else {
        // System disabled - gray highlight
        it.filled_rectangle(0, 26, 128, 16, COLOR_GRAY);
        it.print(2, 30, id(font_medium), COLOR_BLACK, "SYSTEM DISABLED");
      }

      // Capture statistics
      it.printf(0, 42, id(font_small), "Captures: %.0f", id(capture_count_sensor).state);

      // Environmental data from BME280
      if (id(env_temperature).has_state()) {
        it.printf(0, 47, id(font_small), "Env: %.1fÂ°C  %.0f%%RH",
                 id(env_temperature).state, id(env_humidity).state);
      }

      // System monitoring
      if (id(wifi_signal).has_state()) {
        it.printf(0, 56, id(font_small), "WiFi: %.0fdBm  CPU: %.1fÂ°C",
                  id(wifi_signal).state, id(esp32_temp).state);
      } else {
        it.printf(0, 56, id(font_small), "ESP32 Temp: %.1fÂ°C", id(esp32_temp).state);
      }

      // Thermal warning indicator
      if (id(esp32_temp).has_state() && id(esp32_temp).state > 75.0) {
        it.print(120, 56, id(font_small), "!");  // Temperature warning
      }

      // Current sensor if enabled
      if (id(vacuum_current).has_state()) {
        it.printf(0, 70, id(font_small), "Vacuum: %.1fA", id(vacuum_current).state);
      }

      // PIR motion status if enabled
      if (id(pir_sensor).state) {
        it.printf(80, 70, id(font_small), "Motion");
      }

# Fonts for display
font:
  - file: "gfonts://Roboto Mono"
    id: font_small
    size: 8
  - file: "gfonts://Roboto Mono"
    id: font_medium
    size: 12

# Global variables for state tracking
globals:
  - id: capture_count
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_trigger_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: total_vacuum_runtime
    type: float
    restore_value: yes
    initial_value: '0'

  - id: fault_count
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_fault_type
    type: std::string
    restore_value: yes
    initial_value: '""'

# Script for PIR-based power saving
script:
  - id: activate_tof_sensor
    then:
      - if:
          condition:
            switch.is_on: power_saving_mode
          then:
            - logger.log: "Motion detected, activating ToF sensor for precise detection"
            # Here we would enable the ToF sensor which would normally be off in power saving mode
            - delay: 30s
            - logger.log: "Returning to power saving mode"

# Emergency sleep mode for thermal protection
deep_sleep:
  id: emergency_sleep
  sleep_duration: 60s  # Cool down period

# Web server for local configuration
web_server:
  port: 80
  version: 2
  include_internal: true

# System information with voltage specifications
text_sensor:
  - platform: template
    name: "System Voltage"
    id: system_voltage
    lambda: 'return {"${line_voltage}"};'

  - platform: template
    name: "Line Frequency"
    id: system_frequency
    lambda: 'return {"${line_frequency}"};'

  - platform: template
    name: "Safety Standard"
    id: system_safety_standard
    lambda: 'return {"${safety_standard}"};'

  - platform: template
    name: "Max Current Rating"
    id: max_current_rating
    lambda: 'return {"${max_current}"};'

  - platform: wifi_info
    ip_address:
      name: "IP Address"
      id: ip_address
    ssid:
      name: "Connected SSID"
      id: wifi_ssid
    mac_address:
      name: "MAC Address"
      id: mac_address

  - platform: version
    name: "ESPHome Version"

  # Fault type reporting
  - platform: template
    name: "Last Fault Type"
    id: last_fault_type_sensor
    icon: "mdi:alert-circle"
    lambda: |-
      return id(last_fault_type);

# Configurable parameters for easy tuning
number:
  - platform: template
    name: "Detection Threshold (mm)"
    id: detection_threshold
    min_value: 50
    max_value: 500
    step: 10
    initial_value: 150
    restore_value: true
    optimistic: true

  - platform: template
    name: "Vacuum Runtime (seconds)"
    id: vacuum_runtime
    min_value: 1
    max_value: 30
    step: 1
    initial_value: 8
    restore_value: true
    optimistic: true

  - platform: template
    name: "Cooldown Period (seconds)"
    id: cooldown_period
    min_value: 10
    max_value: 300
    step: 5
    initial_value: 30
    restore_value: true
    optimistic: true

# Power optimization for TTGO option
interval:
  - interval: 5min
    then:
      - if:
          condition:
            and:
              - switch.is_on: power_saving_mode
              - binary_sensor.is_off: pir_sensor
          then:
            - logger.log: "Optimizing power consumption in battery mode"
            - display.turn_off: tft_display
            # Here we would implement power saving for sensors
